"use strict";
/* tslint:disable:no-use-before-declare */
Object.defineProperty(exports, "__esModule", { value: true });
const Try_1 = require("./Try");
const Optional_1 = require("./Optional");
function Future(f) {
    if (f instanceof Promise) {
        return new FutureImpl(f);
    }
    else {
        return new FutureImpl(new Promise((resolve, reject) => {
            Try_1.Try(f).fold(e => reject(e), a => resolve(a));
        }));
    }
}
exports.Future = Future;
(function (Future) {
    function fromPromise(p) {
        return new FutureImpl(p);
    }
    Future.fromPromise = fromPromise;
    function unit() {
        return new FutureImpl(Promise.resolve(undefined), Try_1.Success(undefined));
    }
    Future.unit = unit;
    function failed(e) {
        return new FutureImpl(Promise.reject(e), Try_1.Failure(e));
    }
    Future.failed = failed;
    function successful(a) {
        return new FutureImpl(Promise.resolve(a), Try_1.Success(a));
    }
    Future.successful = successful;
    function fromTry(t) {
        return t.fold((e) => this.failed(e), (a) => this.successful(a));
    }
    Future.fromTry = fromTry;
    function sequence(fus) {
        return new FutureImpl(Promise.all(fus.map(a => a.promise)));
    }
    Future.sequence = sequence;
    function firstCompletedOf(fus) {
        return new FutureImpl(Promise.race(fus.map(a => a.promise)));
    }
    Future.firstCompletedOf = firstCompletedOf;
    function find(fus, f) {
        let searchRecursive = (fr) => {
            if (fr.length === 0) {
                return Future.successful(Optional_1.None);
            }
            const [fh, ...ft] = fr;
            return fh.transformWith(t => t.fold(e => searchRecursive(ft), a => f(a) ? Future.successful(Optional_1.Optional.apply(a)) : searchRecursive(ft)));
        };
        return searchRecursive(fus);
    }
    Future.find = find;
    function foldLeft(fu, zero, f) {
        let recursive = (fr, acc) => {
            if (fr.length === 0) {
                return Future.successful(acc);
            }
            const [fh, ...ft] = fr;
            return fh.flatMap(a => recursive(ft, f(acc, a)));
        };
        return recursive(fu, zero);
    }
    Future.foldLeft = foldLeft;
    function traverse(fu, f) {
        const fzero = Future.successful([]);
        if (fu.length === 0) {
            return fzero;
        }
        return fu.reduce((fbs, a) => fbs.zipWith(() => f(a), (bs, fa) => {
            bs.push(fa);
            return bs;
        }), fzero);
    }
    Future.traverse = traverse;
})(Future = exports.Future || (exports.Future = {}));
class FutureImpl {
    constructor(_promise, already) {
        this._promise = _promise;
        this.completeValue = Optional_1.None;
        if (already) {
            this.completeValue = Optional_1.Some(already);
        }
        else {
            _promise.then(a => this.completeValue = Optional_1.Some(Try_1.Success(a)), e => this.completeValue = Optional_1.Some(Try_1.Failure(e)));
        }
    }
    get promise() {
        return this._promise;
    }
    onComplete(f) {
        this.promise.then(a => f(Try_1.Success(a)), e => f(Try_1.Failure(e)));
    }
    isCompleted() {
        return this.completeValue.nonEmpty;
    }
    value() {
        return this.completeValue;
    }
    failed() {
        return this.transform(t => t.fold(e => Try_1.Success(e), a => Try_1.Failure(new Error('Future.failed not completed with a throwable.'))));
    }
    foreach(f) {
        this.onComplete(t => t.foreach(f));
    }
    tryPromise(f) {
        try {
            return f();
        }
        catch (e) {
            return Promise.reject(e);
        }
    }
    transform(f) {
        return new FutureImpl(this.promise.then((a) => this.tryPromise(() => f(Try_1.Success(a)).fold((e) => Promise.reject(e), (b) => Promise.resolve(b))), e => this.tryPromise(() => f(Try_1.Failure(e)).fold((e) => Promise.reject(e), (b) => Promise.resolve(b)))));
    }
    transform1(fs, ff) {
        return this.transform(t => t.fold(e => {
            try {
                return Try_1.Failure(ff(e));
            }
            catch (e) {
                return Try_1.Failure(e);
            }
        }, a => Try_1.Try(() => fs(a))));
    }
    transformWith(f) {
        return new FutureImpl(this.promise.then((a) => this.tryPromise(() => f(Try_1.Success(a)).promise), e => this.tryPromise(() => f(Try_1.Failure(e)).promise)));
    }
    map(f) {
        return this.transform(t => t.map(f));
    }
    flatMap(f) {
        return this.transformWith(t => t.fold(e => Future.failed(e), a => f(a)));
    }
    filter(f) {
        return this.map(a => {
            if (f(a)) {
                return a;
            }
            else {
                throw new Error('Future.filter predicate is not satisfied');
            }
        });
    }
    recover(f) {
        return this.transform(t => t.recover(f));
    }
    recoverWith(f) {
        return this.transformWith(t => t.fold(e => f(e).fold(() => Future.failed(e), a => a), a => Future.successful(a)));
    }
    zip(fu) {
        return this.flatMap(a => fu().map(b => [a, b]));
    }
    zipWith(fu, f) {
        return this.flatMap(a => fu().map(b => f(a, b)));
    }
    fallbackTo(fu) {
        return this.recoverWith(e => Optional_1.Some(fu())).recoverWith(e => Optional_1.Some(this));
    }
    andThen(f) {
        return this.transform(t => {
            try {
                f(t);
            }
            catch (e) {
                if (typeof console !== 'undefined') {
                    console.error(e);
                }
            }
            return t;
        });
    }
    apply1(ob, f) {
        return this.zipWith(ob, f);
    }
    apply2(ob, oc, f) {
        return this.flatMap(a => ob().flatMap(b => oc().map(c => f(a, b, c))));
    }
    chain(ob) {
        return new FutureBuilder1(this, ob);
    }
}
/**
 * FutureBuilder.
 */
class FutureBuilder1 {
    constructor(oa, ob) {
        this.oa = oa;
        this.ob = ob;
    }
    run(f) {
        return this.oa.flatMap(a => this.ob().map(b => f(a, b)));
    }
    chain(oc) {
        return new FutureBuilder2(this.oa, this.ob, oc);
    }
}
exports.FutureBuilder1 = FutureBuilder1;
class FutureBuilder2 {
    constructor(oa, ob, oc) {
        this.oa = oa;
        this.ob = ob;
        this.oc = oc;
    }
    run(f) {
        return this.oa.flatMap(a => this.ob().flatMap(b => this.oc().map(c => f(a, b, c))));
    }
    chain(od) {
        return new FutureBuilder3(this.oa, this.ob, this.oc, od);
    }
}
exports.FutureBuilder2 = FutureBuilder2;
class FutureBuilder3 {
    constructor(oa, ob, oc, od) {
        this.oa = oa;
        this.ob = ob;
        this.oc = oc;
        this.od = od;
    }
    run(f) {
        return this.oa.flatMap(a => this.ob().flatMap(b => this.oc().flatMap(c => this.od().map(d => f(a, b, c, d)))));
    }
    chain(oe) {
        return new FutureBuilder4(this.oa, this.ob, this.oc, this.od, oe);
    }
}
exports.FutureBuilder3 = FutureBuilder3;
class FutureBuilder4 {
    constructor(oa, ob, oc, od, oe) {
        this.oa = oa;
        this.ob = ob;
        this.oc = oc;
        this.od = od;
        this.oe = oe;
    }
    run(f) {
        return this.oa.flatMap(a => this.ob().flatMap(b => this.oc().flatMap(c => this.od().flatMap(d => this.oe().map(e => f(a, b, c, d, e))))));
    }
    chain(of) {
        return new FutureBuilder5(this.oa, this.ob, this.oc, this.od, this.oe, of);
    }
}
exports.FutureBuilder4 = FutureBuilder4;
class FutureBuilder5 {
    constructor(oa, ob, oc, od, oe, of) {
        this.oa = oa;
        this.ob = ob;
        this.oc = oc;
        this.od = od;
        this.oe = oe;
        this.of = of;
    }
    run(f) {
        return this.oa.flatMap(a => this.ob().flatMap(b => this.oc().flatMap(c => this.od().flatMap(d => this.oe().flatMap(e => this.of().map(ff => f(a, b, c, d, e, ff)))))));
    }
}
exports.FutureBuilder5 = FutureBuilder5;
