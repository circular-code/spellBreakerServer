import 'reflect-metadata';
import { Supplier, Predicate, Mapper, Func } from './types';
/**
 * Represents optional values. Instances of `Optional`
 *  are either an instance of $some or the object $none.
 *
 *  The most idiomatic way to use an $optional instance is to treat it
 *  as a collection or monad and use `map`,`flatMap`, `filter`, or
 *  `foreach`:
 */
export declare abstract class Optional<A> {
    /** Returns true if the option is $none, false otherwise. */
    isEmpty: boolean;
    /** Returns true if the option is an instance of $some, false otherwise. */
    nonEmpty: boolean;
    /**
     * Returns the option's value.
     * @note The option must be nonEmpty.
     */
    abstract get(): A;
    /**
     * Returns the option's value if the option is nonempty, otherwise
     * return the result of evaluating `default`.
     *
     * @param a the default expression.
     */
    getOrElse<B extends A>(a: Supplier<B>): A;
    /**
     * Returns a $some containing the result of applying $f to this $option's value if this $option is nonempty.
     * Otherwise return $none.
     *
     * @note This is similar to `flatMap` except here, $f does not need to wrap its result in an $option.
     *
     * @param f the function to apply
     * @see flatMap
     * @see foreach
     */
    map<B>(f: Mapper<A, B>): Optional<B>;
    /**
     * Returns the result of applying $f to this $option's
     * value if the $option is nonempty.  Otherwise, evaluates
     * expression `ifEmpty`.
     *
     * @note This is equivalent to `$option map f getOrElse ifEmpty`.
     *
     * @param ifEmpty the expression to evaluate if empty.
     * @param f       the function to apply if nonempty.
     */
    fold<B>(ifEmpty: Supplier<B>, f: Mapper<A, B>): B;
    /**
     * Returns the result of applying $f to this $option's value if this $option is nonempty.
     * Returns $none if this $option is empty.
     * Slightly different from `map` in that $f is expected to return an $option (which could be $none).
     *
     * @param f the function to apply
     * @see map
     * @see foreach
     */
    flatMap<B>(f: Mapper<A, Optional<B>>): Optional<B>;
    /**
     * Returns this $option if it is nonempty '''and''' applying the predicate $F to
     * this $option's value returns true. Otherwise, return $none.
     *
     * @param f the predicate used for testing.
     */
    filter(f: Predicate<A>): Optional<A>;
    /**
     * Tests whether the option contains a given value as an element.
     *
     * @param b the element to test.
     * @return `true` if the option has an element that is equal (as determined by `==`) to `elem`, `false` otherwise.
     */
    contains<B extends A>(b: B): boolean;
    /**
     * Returns true if this option is nonempty '''and''' the predicate $f returns true when applied to this $option's value.
     * Otherwise, returns false.
     *
     * @param f the predicate to test
     */
    exists(f: Predicate<A>): boolean;
    /**
     * Returns true if this option is empty '''or''' the predicate $f returns true when applied to this $option's value.
     *
     * @param f the predicate to test
     */
    forall(f: Predicate<A>): boolean;
    /**
     * Apply the given procedure $f to the option's value, if it is nonempty. Otherwise, do nothing.
     *
     * @param f the procedure to apply.
     * @see map
     * @see flatMap
     */
    foreach(f: Func<A>): void;
    /**
     * Returns this $option if it is nonempty, otherwise return the result of evaluating `alternative`.
     *
     * @param ob the alternative expression.
     */
    orElse<B extends A>(ob: Supplier<Optional<B>>): Optional<A>;
    apply1<B, C>(ob: Supplier<Optional<B>>, f: (a: A, b: B) => C): Optional<C>;
    apply2<B, C, D>(ob: Supplier<Optional<B>>, oc: Supplier<Optional<C>>, f: (a: A, b: B, c: C) => D): Optional<D>;
    apply3<B, C, D, E>(ob: Supplier<Optional<B>>, oc: Supplier<Optional<C>>, od: Supplier<Optional<D>>, f: (a: A, b: B, c: C, d: D) => E): Optional<E>;
    apply4<B, C, D, E, F>(ob: Supplier<Optional<B>>, oc: Supplier<Optional<C>>, od: Supplier<Optional<D>>, oe: Supplier<Optional<E>>, f: (a: A, b: B, c: C, d: D, e: E) => F): Optional<F>;
    apply5<B, C, D, E, F, G>(ob: Supplier<Optional<B>>, oc: Supplier<Optional<C>>, od: Supplier<Optional<D>>, oe: Supplier<Optional<E>>, of: Supplier<Optional<F>>, f: (a: A, b: B, c: C, d: D, e: E, f: F) => G): Optional<G>;
    chain<B>(ob: Supplier<Optional<B>>): OptionalBuilder1<A, B>;
    static apply<A>(a: A | null | undefined): Optional<A>;
}
/**
 * Class `Some[A]` represents existing values of type `A`.
 */
export declare function Some<A>(a: A): Optional<A>;
/**
 * This object represents non-existent values.
 */
export declare const None: Optional<any>;
export declare class OptionalBuilder1<A, B> {
    private oa;
    private ob;
    constructor(oa: Optional<A>, ob: Supplier<Optional<B>>);
    run<C>(f: (a: A, b: B) => C): Optional<C>;
    chain<C>(oc: Supplier<Optional<C>>): OptionalBuilder2<A, B, C>;
}
export declare class OptionalBuilder2<A, B, C> {
    private oa;
    private ob;
    private oc;
    constructor(oa: Optional<A>, ob: Supplier<Optional<B>>, oc: Supplier<Optional<C>>);
    run<D>(f: (a: A, b: B, c: C) => D): Optional<D>;
    chain<D>(od: Supplier<Optional<D>>): OptionalBuilder3<A, B, C, D>;
}
export declare class OptionalBuilder3<A, B, C, D> {
    private oa;
    private ob;
    private oc;
    private od;
    constructor(oa: Optional<A>, ob: Supplier<Optional<B>>, oc: Supplier<Optional<C>>, od: Supplier<Optional<D>>);
    run<E>(f: (a: A, b: B, c: C, d: D) => E): Optional<E>;
    chain<E>(oe: Supplier<Optional<E>>): OptionalBuilder4<A, B, C, D, E>;
}
export declare class OptionalBuilder4<A, B, C, D, E> {
    private oa;
    private ob;
    private oc;
    private od;
    private oe;
    constructor(oa: Optional<A>, ob: Supplier<Optional<B>>, oc: Supplier<Optional<C>>, od: Supplier<Optional<D>>, oe: Supplier<Optional<E>>);
    run<F>(f: (a: A, b: B, c: C, d: D, e: E) => F): Optional<F>;
    chain<F>(of: Supplier<Optional<F>>): OptionalBuilder5<A, B, C, D, E, F>;
}
export declare class OptionalBuilder5<A, B, C, D, E, F> {
    private oa;
    private ob;
    private oc;
    private od;
    private oe;
    private of;
    constructor(oa: Optional<A>, ob: Supplier<Optional<B>>, oc: Supplier<Optional<C>>, od: Supplier<Optional<D>>, oe: Supplier<Optional<E>>, of: Supplier<Optional<F>>);
    run<G>(f: (a: A, b: B, c: C, d: D, e: E, f: F) => G): Optional<G>;
}
