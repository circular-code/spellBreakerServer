import { Optional } from './Optional';
import { Either } from './Either';
/**
 * The `Try` type represents a computation that may either result in an exception, or return a
 * successfully computed value. It's similar to, but semantically different from the Either type.
 *
 * Instances of `Try<T>`, are either an instance of Success<T> or Failure<T>.
 *
 * For example, `Try` can be used to perform division on a user-defined input, without the need to do explicit
 * exception-handling in all of the places that an exception might occur.
 *
 * An important property of `Try` shown in the above example is its ability to ''pipeline'', or chain, operations,
 * catching exceptions along the way. The `flatMap` and `map` combinators in the above example each essentially
 * pass off either their successfully completed value, wrapped in the `Success` type for it to be further operated
 * upon by the next combinator in the chain, or the exception wrapped in the `Failure` type usually to be simply
 * passed on down the chain. Combinators such as `recover` and `recoverWith` are designed to provide some type of
 * default behavior in the case of failure.
 */
export interface Try<A> {
    /**
     * Returns `true` if the `Try` is a `Success`, `false` otherwise.
     */
    isSuccess: boolean;
    /**
     * Returns `true` if the `Try` is a `Failure`, `false` otherwise.
     */
    isFailure: boolean;
    /**
     * Returns the value from this `Success` or throws the exception if this is a `Failure`.
     */
    get(): A;
    /**
     * Returns the error from this `Failure` or throws the exception if this is a `Success`.
     */
    getError(): Error;
    /**
     * Applies `fe` if this is a `Failure` or `ff` if this is a `Success`.
     * If `fe` is initially applied and throws an exception,
     * then `ff` is applied with this exception.
     * @param fe the function to apply if this is a `Failure`
     * @param ff the function to apply if this is a `Success`
     */
    fold<B>(fe: (e: Error) => B, ff: (a: A) => B): B;
    /**
     * Returns the value from this `Success` or the given `default` argument if this is a `Failure`.
     *
     * ''Note:'': This will throw an exception if it is not a success and default throws an exception.
     */
    getOrElse<B extends A>(a: () => B): A;
    /**
     * Returns this `Try` if it's a `Success` or the given `default` argument if this is a `Failure`.
     */
    orElse<B extends A>(a: Try<B>): Try<A>;
    /**
     * Applies the given function `f` if this is a `Success`, otherwise returns `Unit` if this is a `Failure`.
     *
     * ''Note:'' If `f` throws, then this method may throw an exception.
     */
    foreach<B>(f: (a: A) => void): void;
    /**
     * Returns the given function applied to the value from this `Success` or returns this if this is a `Failure`.
     */
    flatMap<B>(f: (a: A) => Try<B>): Try<B>;
    /**
     * Maps the given function to the value from this `Success` or returns this if this is a `Failure`.
     */
    map<B>(f: (a: A) => B): Try<B>;
    /**
     * Converts this to a `Failure` if the predicate is not satisfied
     */
    filter(f: (a: A) => boolean): Try<A>;
    /**
     * Inverts this `Try`. If this is a `Failure`, returns its exception wrapped in a `Success`.
     * If this is a `Success`, returns a `Failure` containing an `UnsupportedOperationException`.
     */
    failed(): Try<A>;
    /**
     * Completes this `Try` by applying the function `f` to this if this is of type `Failure`, or conversely, by applying
     * `s` if this is a `Success`.
     */
    transform<B>(fs: (a: A) => Try<B>, ff: (e: Error) => Try<B>): Try<B>;
    /**
     * Applies the given function `f` if this is a `Failure`, otherwise returns this if this is a `Success`.
     * This is like map for the exception.
     */
    recover<B extends A>(f: (e: Error) => Optional<B>): Try<A>;
    /**
     * Applies the given function `f` if this is a `Failure`, otherwise returns this if this is a `Success`.
     * This is like `flatMap` for the exception.
     */
    recoverWith<B extends A>(f: (e: Error) => Optional<Try<B>>): Try<A>;
    /**
     * Returns `None` if this is a `Failure` or a `Some` containing the value if this is a `Success`.
     */
    toOptional(): Optional<A>;
    toEither(): Either<Error, A>;
    apply1<B, C>(ob: Try<B>, f: (a: A, b: B) => C): Try<C>;
    apply2<B, C, D>(ob: Try<B>, oc: Try<C>, f: (a: A, b: B, c: C) => D): Try<D>;
    apply3<B, C, D, E>(ob: Try<B>, oc: Try<C>, od: Try<D>, f: (a: A, b: B, c: C, d: D) => E): Try<E>;
    apply4<B, C, D, E, F>(ob: Try<B>, oc: Try<C>, od: Try<D>, oe: Try<E>, f: (a: A, b: B, c: C, d: D, e: E) => F): Try<F>;
    apply5<B, C, D, E, F, G>(ob: Try<B>, oc: Try<C>, od: Try<D>, oe: Try<E>, of: Try<F>, f: (a: A, b: B, c: C, d: D, e: E, f: F) => G): Try<G>;
    chain<B>(ob: Try<B>): TryBuilder1<A, B>;
}
export declare function Try<A>(f: () => A): Try<A>;
export declare function Success<A>(a: A): Try<A>;
export declare function Failure<A>(e: Error): Try<A>;
export declare class TryBuilder1<A, B> {
    private oa;
    private ob;
    constructor(oa: Try<A>, ob: Try<B>);
    run<C>(f: (a: A, b: B) => C): Try<C>;
    chain<C>(oc: Try<C>): TryBuilder2<A, B, C>;
}
export declare class TryBuilder2<A, B, C> {
    private oa;
    private ob;
    private oc;
    constructor(oa: Try<A>, ob: Try<B>, oc: Try<C>);
    run<D>(f: (a: A, b: B, c: C) => D): Try<D>;
    chain<D>(od: Try<D>): TryBuilder3<A, B, C, D>;
}
export declare class TryBuilder3<A, B, C, D> {
    private oa;
    private ob;
    private oc;
    private od;
    constructor(oa: Try<A>, ob: Try<B>, oc: Try<C>, od: Try<D>);
    run<E>(f: (a: A, b: B, c: C, d: D) => E): Try<E>;
    chain<E>(oe: Try<E>): TryBuilder4<A, B, C, D, E>;
}
export declare class TryBuilder4<A, B, C, D, E> {
    private oa;
    private ob;
    private oc;
    private od;
    private oe;
    constructor(oa: Try<A>, ob: Try<B>, oc: Try<C>, od: Try<D>, oe: Try<E>);
    run<F>(f: (a: A, b: B, c: C, d: D, e: E) => F): Try<F>;
    chain<F>(of: Try<F>): TryBuilder5<A, B, C, D, E, F>;
}
export declare class TryBuilder5<A, B, C, D, E, F> {
    private oa;
    private ob;
    private oc;
    private od;
    private oe;
    private of;
    constructor(oa: Try<A>, ob: Try<B>, oc: Try<C>, od: Try<D>, oe: Try<E>, of: Try<F>);
    run<G>(f: (a: A, b: B, c: C, d: D, e: E, f: F) => G): Try<G>;
}
