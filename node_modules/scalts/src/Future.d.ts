import { Try } from './Try';
import { Optional } from './Optional';
import { Supplier } from './types';
/**
 * A `Future` represents a value which may or may not *currently* be available,
 * but will be available at some point, or an exception if that value could not be made available.
 */
export interface Future<A> {
    readonly promise: Promise<A>;
    /**
     * When this future is completed, either through an exception, or a value,
     * apply the provided function.
     *
     * If the future has already been completed,
     * this will either be applied immediately or be scheduled asynchronously.
     *
     * Note that the returned value of `f` will be discarded.
     */
    onComplete<B>(f: (t: Try<A>) => B): void;
    /**
     * Returns whether the future had already been completed with
     * a value or an exception.
     *
     * $nonDeterministic
     */
    isCompleted(): boolean;
    /**
     * The current value of this `Future`.
     *
     * $nonDeterministic
     *
     * If the future was not completed the returned value will be `None`.
     * If the future was completed the value will be `Some(Success(t))`
     * if it contained a valid result, or `Some(Failure(error))` if it contained
     * an exception.
     */
    value(): Optional<Try<A>>;
    /**
     * The returned `Future` will be successfully completed with the `Error` of the original `Future`
     * if the original `Future` fails.
     *
     * If the original `Future` is successful, the returned `Future` is failed with a `NoSuchElementException`.
     */
    failed(): Future<Error>;
    /**
     * Asynchronously processes the value in the future once the value becomes available.
     *
     * WARNING: Will not be called if this future is never completed or if it is completed with a failure.
     *
     * $swallowsExceptions
     */
    foreach<B>(f: (a: A) => B): void;
    /**
     * Creates a new Future by applying the specified function to the result
     * of this Future. If there is any non-fatal exception thrown when 'f'
     * is applied then that exception will be propagated to the resulting future.
     */
    transform<B>(f: (t: Try<A>) => Try<B>): Future<B>;
    /**
     * Creates a new future by applying the 's' function to the successful result of
     * this future, or the 'f' function to the failed result. If there is any non-fatal
     * exception thrown when 's' or 'f' is applied, that exception will be propagated
     * to the resulting future.
     */
    transform1<B>(s: (a: A) => B, f: (e: Error) => Error): Future<B>;
    /**
     * Creates a new Future by applying the specified function, which produces a Future, to the result
     * of this Future. If there is any non-fatal exception thrown when 'f'
     * is applied then that exception will be propagated to the resulting future.
     */
    transformWith<B>(f: (t: Try<A>) => Future<B>): Future<B>;
    /**
     * Creates a new future by applying a function to the successful result of
     * this future. If this future is completed with an exception then the new
     * future will also contain this exception.
     */
    map<B>(f: (a: A) => B): Future<B>;
    /**
     * Creates a new future by applying a function to the successful result of
     * this future, and returns the result of the function as the new future.
     * If this future is completed with an exception then the new future will
     * also contain this exception.
     */
    flatMap<B>(f: (a: A) => Future<B>): Future<B>;
    /**
     * Creates a new future by filtering the value of the current future with a predicate.
     *
     * If the current future contains a value which satisfies the predicate, the new future will also hold that value.
     * Otherwise, the resulting future will fail with a `NoSuchElementException`.
     *
     * If the current future fails, then the resulting future also fails.
     */
    filter(f: (a: A) => boolean): Future<A>;
    /**
     * Creates a new future that will handle any matching Error that this
     * future might contain. If there is no match, or if this future contains
     * a valid result then the new future will contain the same.
     * @param f
     */
    recover<B extends A>(f: (e: Error) => Optional<B>): Future<A>;
    /**
     * Creates a new future that will handle any matching throwable that this
     * future might contain by assigning it a value of another future.
     *
     * If there is no match, or if this future contains
     * a valid result then the new future will contain the same result.
     * @param f
     */
    recoverWith<B extends A>(f: (e: Error) => Optional<Future<B>>): Future<A>;
    /**
     * Zips the values of `this` and `that` future, and creates
     * a new future holding the tuple of their results.
     *
     * If `this` future fails, the resulting future is failed
     * with the throwable stored in `this`.
     * Otherwise, if `that` future fails, the resulting future is failed
     * with the throwable stored in `that`.
     */
    zip<B>(fu: Supplier<Future<B>>): Future<[A, B]>;
    /**
     * Zips the values of `this` and `that` future using a function `f`,
     * and creates a new future holding the result.
     *
     * If `this` future fails, the resulting future is failed
     * with the throwable stored in `this`.
     * Otherwise, if `that` future fails, the resulting future is failed
     * with the throwable stored in `that`.
     * If the application of `f` throws a throwable, the resulting future
     * is failed with that throwable if it is non-fatal.
     * @param f
     */
    zipWith<B, C>(fu: Supplier<Future<B>>, f: (a: A, b: B) => C): Future<C>;
    /**
     * Creates a new future which holds the result of this future if it was completed successfully, or, if not,
     * the result of the `that` future if `that` is completed successfully.
     * If both futures are failed, the resulting future holds the throwable object of the first future.
     *
     * Using this method will not cause concurrent programs to become nondeterministic.
     */
    fallbackTo<B extends A>(fu: Supplier<Future<B>>): Future<A>;
    /**
     * Applies the side-effecting function to the result of this future, and returns
     * a new future with the result of this future.
     *
     * This method allows one to enforce that the callbacks are executed in a
     * specified order.
     *
     * Note that if one of the chained `andThen` callbacks throws
     * an exception, that exception is not propagated to the subsequent `andThen`
     * callbacks. Instead, the subsequent `andThen` callbacks are given the original
     * value of this future.
     */
    andThen<B>(f: (t: Try<A>) => B): Future<A>;
    apply1<B, C>(ob: Supplier<Future<B>>, f: (a: A, b: B) => C): Future<C>;
    apply2<B, C, D>(ob: Supplier<Future<B>>, oc: Supplier<Future<C>>, f: (a: A, b: B, c: C) => D): Future<D>;
    chain<B>(ob: Supplier<Future<B>>): FutureBuilder1<A, B>;
}
export declare function Future<A>(f: Promise<A> | (() => A)): Future<A>;
export declare namespace Future {
    function fromPromise<A>(p: Promise<A>): Future<A>;
    function unit(): Future<void>;
    function failed<A>(e: Error): Future<A>;
    function successful<A>(a: A): Future<A>;
    function fromTry<A>(t: Try<A>): Future<A>;
    function sequence<A>(fus: Array<Future<A>>): Future<Array<A>>;
    function firstCompletedOf<A>(fus: Array<Future<A>>): Future<A>;
    function find<A>(fus: Array<Future<A>>, f: (a: A) => boolean): Future<Optional<A>>;
    function foldLeft<A, B>(fu: Array<Future<A>>, zero: B, f: (b: B, a: A) => B): Future<B>;
    function traverse<A, B>(fu: Array<A>, f: (a: A) => Future<B>): Future<Array<B>>;
}
/**
 * FutureBuilder.
 */
export declare class FutureBuilder1<A, B> {
    private oa;
    private ob;
    constructor(oa: Future<A>, ob: Supplier<Future<B>>);
    run<C>(f: (a: A, b: B) => C): Future<C>;
    chain<C>(oc: Supplier<Future<C>>): FutureBuilder2<A, B, C>;
}
export declare class FutureBuilder2<A, B, C> {
    private oa;
    private ob;
    private oc;
    constructor(oa: Future<A>, ob: Supplier<Future<B>>, oc: Supplier<Future<C>>);
    run<D>(f: (a: A, b: B, c: C) => D): Future<D>;
    chain<D>(od: Supplier<Future<D>>): FutureBuilder3<A, B, C, D>;
}
export declare class FutureBuilder3<A, B, C, D> {
    private oa;
    private ob;
    private oc;
    private od;
    constructor(oa: Future<A>, ob: Supplier<Future<B>>, oc: Supplier<Future<C>>, od: Supplier<Future<D>>);
    run<E>(f: (a: A, b: B, c: C, d: D) => E): Future<E>;
    chain<E>(oe: Supplier<Future<E>>): FutureBuilder4<A, B, C, D, E>;
}
export declare class FutureBuilder4<A, B, C, D, E> {
    private oa;
    private ob;
    private oc;
    private od;
    private oe;
    constructor(oa: Future<A>, ob: Supplier<Future<B>>, oc: Supplier<Future<C>>, od: Supplier<Future<D>>, oe: Supplier<Future<E>>);
    run<F>(f: (a: A, b: B, c: C, d: D, e: E) => F): Future<F>;
    chain<F>(of: Supplier<Future<F>>): FutureBuilder5<A, B, C, D, E, F>;
}
export declare class FutureBuilder5<A, B, C, D, E, F> {
    private oa;
    private ob;
    private oc;
    private od;
    private oe;
    private of;
    constructor(oa: Future<A>, ob: Supplier<Future<B>>, oc: Supplier<Future<C>>, od: Supplier<Future<D>>, oe: Supplier<Future<E>>, of: Supplier<Future<F>>);
    run<G>(f: (a: A, b: B, c: C, d: D, e: E, f: F) => G): Future<G>;
}
