import { Optional } from './Optional';
import { Supplier } from './types';
/**
 * Represents a value of one of two possible types (a disjoint union.)
 * An instance of Either is either an instance of Left or Right.
 *
 * A common use of Either is as an alternative to Option for dealing
 * with possible missing values.  In this usage, None is replaced
 * with a Left which can contain useful information.
 * Right takes the place of Some.  Convention dictates
 * that Left is used for failure and Right is used for success.
 */
export interface Either<A, B> {
    readonly value: A | B;
    /**
     * Returns `true` if this is a `Left`, `false` otherwise.
     */
    readonly isLeft: boolean;
    /**
     * Returns `true` if this is a `Right`, `false` otherwise.
     */
    readonly isRight: boolean;
    /**
     * Projects this `Either` as a `Right`.
     */
    left(): LeftProjection<A, B>;
    /**
     * Projects this `Either` as a `Right`.
     */
    right(): RightProjection<A, B>;
    /**
     * Applies `fa` if this is a `Left` or `fb` if this is a `Right`.
     * @param fa the function to apply if this is a `Left`
     * @param fb the function to apply if this is a `Right`
     */
    fold<X>(fa: (a: A) => X, fb: (b: B) => X): X;
    /**
     * If this is a `Left`, then return the left value in `Right` or vice versa.
     */
    swap(): Either<B, A>;
    /**
     * Executes the given side-effecting function if this is a `Right`.
     * @param f The side-effecting function to execute.
     */
    foreach(f: (b: B) => void): void;
    /**
     * Returns the value from this `Right` or the given argument if this is a `Left`.
     * @param dv default value
     */
    getOrElse(dv: () => B): B;
    /**
     * Returns `true` if this is a `Right` and its value is equal to `elem` (as determined by `==`),
     * returns `false` otherwise.
     * @param elem
     */
    contains(elem: B): boolean;
    /**
     * Returns `true` if `Left` or returns the result of the application of
     * the given function to the `Right` value.
     */
    forall(f: (v: B) => boolean): boolean;
    /**
     * Returns `false` if `Left` or returns the result of the application of
     * the given function to the `Right` value.
     * @param f predicate
     */
    exists(f: (v: B) => boolean): boolean;
    /**
     * The given function is applied if this is a `Right`.
     * @param f
     */
    map<Y>(f: (v: B) => Y): Either<A, Y>;
    /**
     * Binds the given function across `Right`.
     * @param f
     */
    flatMap<Y>(f: (v: B) => Either<A, Y>): Either<A, Y>;
    /**
     * Returns a `Some` containing the `Right` value
     * if it exists or a `None` if this is a `Left`.
     */
    toOptional(): Optional<B>;
    /**
     * Match function. will call pf.Left if this is a `Left` or pf.Right if this is a `Right`.
     * @param pf partial function.
     */
    match<C>(pf: {
        Left: (v: A) => C;
        Right: (v: B) => C;
    }): C;
    /** @override */
    chain<C>(ob: Supplier<Either<any, C>>): EitherBuilder1<B, C>;
    apply1<C, D>(ob: Supplier<Either<A, C>>, f: (a: B, b: C) => D): Either<A, D>;
    apply2<C, D, E>(ob: Supplier<Either<A, C>>, oc: Supplier<Either<A, D>>, f: (a: B, b: C, c: D) => E): Either<A, E>;
    apply3<C, D, E, F>(ob: Supplier<Either<A, C>>, oc: Supplier<Either<A, D>>, od: Supplier<Either<A, E>>, f: (a: B, b: C, c: D, d: E) => F): Either<A, F>;
    apply4<C, D, E, F, G>(ob: Supplier<Either<A, C>>, oc: Supplier<Either<A, D>>, od: Supplier<Either<A, E>>, oe: Supplier<Either<A, F>>, f: (a: B, b: C, c: D, d: E, e: F) => G): Either<A, G>;
    apply5<C, D, E, F, G, H>(ob: Supplier<Either<A, C>>, oc: Supplier<Either<A, D>>, od: Supplier<Either<A, E>>, oe: Supplier<Either<A, F>>, of: Supplier<Either<A, G>>, f: (a: B, b: C, c: D, d: E, e: F, f: G) => H): Either<A, H>;
}
/**
 * The right side of the disjoint union, as opposed to the Left side.
 * @param b
 * @constructor
 */
export declare function Right<A, B>(b: B): Either<A, B>;
/**
 * The left side of the disjoint union, as opposed to the Right side.
 * @param a
 * @constructor
 */
export declare function Left<A, B>(a: A): Either<A, B>;
export declare function Either<A, B>(cond: boolean, left: () => A, right: () => B): Either<A, B>;
/**
 * Left project.
 */
export declare class LeftProjection<A, B> {
    private self;
    constructor(self: Either<A, B>);
    toString(): string;
    get(): A;
    foreach(f: (a: A) => void): void;
    getOrElse<X extends A>(x: () => X): A;
    forall(f: (a: A) => boolean): boolean;
    exists(f: (a: A) => boolean): boolean;
    filter(f: (a: A) => boolean): Optional<Either<A, B>>;
    map<X>(f: (a: A) => X): Either<X | A, B>;
    flatMap<X>(f: (a: A) => Either<X, B>): Either<X | A, B>;
    toOptional(): Optional<A>;
}
/**
 * Left project.
 */
export declare class RightProjection<A, B> {
    private self;
    constructor(self: Either<A, B>);
    toString(): string;
    get(): B;
    foreach(f: (b: B) => void): void;
    getOrElse<X extends B>(x: () => X): B;
    forall(f: (b: B) => boolean): boolean;
    exists(f: (b: B) => boolean): boolean;
    filter(f: (b: B) => boolean): Optional<Either<A, B>>;
    map<X>(f: (b: B) => X): Either<A, X | B>;
    flatMap<X>(f: (a: B) => Either<A, X>): Either<A, X | B>;
    toOptional(): Optional<B>;
}
export declare class EitherBuilder1<A, B> {
    private oa;
    private ob;
    constructor(oa: Either<any, A>, ob: Supplier<Either<any, B>>);
    run<C>(f: (a: A, b: B) => C): Either<any, C>;
    chain<C>(oc: Supplier<Either<any, C>>): EitherBuilder2<A, B, C>;
}
export declare class EitherBuilder2<A, B, C> {
    private oa;
    private ob;
    private oc;
    constructor(oa: Either<any, A>, ob: Supplier<Either<any, B>>, oc: Supplier<Either<any, C>>);
    run<D>(f: (a: A, b: B, c: C) => D): Either<any, D>;
    chain<D>(od: Supplier<Either<any, D>>): EitherBuilder3<A, B, C, D>;
}
export declare class EitherBuilder3<A, B, C, D> {
    private oa;
    private ob;
    private oc;
    private od;
    constructor(oa: Either<any, A>, ob: Supplier<Either<any, B>>, oc: Supplier<Either<any, C>>, od: Supplier<Either<any, D>>);
    run<E>(f: (a: A, b: B, c: C, d: D) => E): Either<any, E>;
    chain<E>(oe: Supplier<Either<any, E>>): EitherBuilder4<A, B, C, D, E>;
}
export declare class EitherBuilder4<A, B, C, D, E> {
    private oa;
    private ob;
    private oc;
    private od;
    private oe;
    constructor(oa: Either<any, A>, ob: Supplier<Either<any, B>>, oc: Supplier<Either<any, C>>, od: Supplier<Either<any, D>>, oe: Supplier<Either<any, E>>);
    run<F>(f: (a: A, b: B, c: C, d: D, e: E) => F): Either<any, F>;
    chain<F>(of: Supplier<Either<any, F>>): EitherBuilder5<A, B, C, D, E, F>;
}
export declare class EitherBuilder5<A, B, C, D, E, F> {
    private oa;
    private ob;
    private oc;
    private od;
    private oe;
    private of;
    constructor(oa: Either<any, A>, ob: Supplier<Either<any, B>>, oc: Supplier<Either<any, C>>, od: Supplier<Either<any, D>>, oe: Supplier<Either<any, E>>, of: Supplier<Either<any, F>>);
    run<G>(f: (a: A, b: B, c: C, d: D, e: E, f: F) => G): Either<any, G>;
}
