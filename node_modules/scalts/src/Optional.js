"use strict";
/* tslint:disable:no-use-before-declare */
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
/**
 * Represents optional values. Instances of `Optional`
 *  are either an instance of $some or the object $none.
 *
 *  The most idiomatic way to use an $optional instance is to treat it
 *  as a collection or monad and use `map`,`flatMap`, `filter`, or
 *  `foreach`:
 */
class Optional {
    /**
     * Returns the option's value if the option is nonempty, otherwise
     * return the result of evaluating `default`.
     *
     * @param a the default expression.
     */
    getOrElse(a) {
        return this.isEmpty ? a() : this.get();
    }
    /**
     * Returns a $some containing the result of applying $f to this $option's value if this $option is nonempty.
     * Otherwise return $none.
     *
     * @note This is similar to `flatMap` except here, $f does not need to wrap its result in an $option.
     *
     * @param f the function to apply
     * @see flatMap
     * @see foreach
     */
    map(f) {
        return this.isEmpty ? exports.None : Some(f(this.get()));
    }
    /**
     * Returns the result of applying $f to this $option's
     * value if the $option is nonempty.  Otherwise, evaluates
     * expression `ifEmpty`.
     *
     * @note This is equivalent to `$option map f getOrElse ifEmpty`.
     *
     * @param ifEmpty the expression to evaluate if empty.
     * @param f       the function to apply if nonempty.
     */
    fold(ifEmpty, f) {
        return this.isEmpty ? ifEmpty() : f(this.get());
    }
    /**
     * Returns the result of applying $f to this $option's value if this $option is nonempty.
     * Returns $none if this $option is empty.
     * Slightly different from `map` in that $f is expected to return an $option (which could be $none).
     *
     * @param f the function to apply
     * @see map
     * @see foreach
     */
    flatMap(f) {
        return this.isEmpty ? exports.None : f(this.get());
    }
    /**
     * Returns this $option if it is nonempty '''and''' applying the predicate $F to
     * this $option's value returns true. Otherwise, return $none.
     *
     * @param f the predicate used for testing.
     */
    filter(f) {
        return this.isEmpty || f(this.get()) ? this : exports.None;
    }
    /**
     * Tests whether the option contains a given value as an element.
     *
     * @param b the element to test.
     * @return `true` if the option has an element that is equal (as determined by `==`) to `elem`, `false` otherwise.
     */
    contains(b) {
        return this.nonEmpty && this.get() === b;
    }
    /**
     * Returns true if this option is nonempty '''and''' the predicate $f returns true when applied to this $option's value.
     * Otherwise, returns false.
     *
     * @param f the predicate to test
     */
    exists(f) {
        return this.nonEmpty && f(this.get());
    }
    /**
     * Returns true if this option is empty '''or''' the predicate $f returns true when applied to this $option's value.
     *
     * @param f the predicate to test
     */
    forall(f) {
        return this.isEmpty || f(this.get());
    }
    /**
     * Apply the given procedure $f to the option's value, if it is nonempty. Otherwise, do nothing.
     *
     * @param f the procedure to apply.
     * @see map
     * @see flatMap
     */
    foreach(f) {
        if (this.nonEmpty) {
            f(this.get());
        }
    }
    /**
     * Returns this $option if it is nonempty, otherwise return the result of evaluating `alternative`.
     *
     * @param ob the alternative expression.
     */
    orElse(ob) {
        return this.isEmpty ? ob() : this;
    }
    // add methods
    apply1(ob, f) {
        return this.flatMap(a => ob().map(b => f(a, b)));
    }
    apply2(ob, oc, f) {
        return this.flatMap(a => ob().flatMap(b => oc().map(c => f(a, b, c))));
    }
    apply3(ob, oc, od, f) {
        return this.flatMap(a => ob().flatMap(b => oc().flatMap(c => od().map(d => f(a, b, c, d)))));
    }
    apply4(ob, oc, od, oe, f) {
        return this.flatMap(a => ob().flatMap(b => oc().flatMap(c => od().flatMap(d => oe().map(e => f(a, b, c, d, e))))));
    }
    apply5(ob, oc, od, oe, of, f) {
        return this.flatMap(a => ob().flatMap(b => oc().flatMap(c => od().flatMap(d => oe().flatMap(e => of().map(ff => f(a, b, c, d, e, ff)))))));
    }
    chain(ob) {
        return new OptionalBuilder1(this, ob);
    }
    static apply(a) {
        return (a !== undefined && a !== null) ? new SomeImpl(a) : exports.None;
    }
}
exports.Optional = Optional;
/**
 * Class `Some[A]` represents existing values of type `A`.
 */
function Some(a) {
    return new SomeImpl(a);
}
exports.Some = Some;
//------------------------------------
//
// Implementation section.
//
//------------------------------------
class SomeImpl extends Optional {
    constructor(value) {
        super();
        this.value = value;
        this.isEmpty = false;
        this.nonEmpty = true;
    }
    get() {
        return this.value;
    }
    toString() {
        return 'Some(' + this.value + ')';
    }
}
class NoneImpl extends Optional {
    constructor() {
        super(...arguments);
        this.isEmpty = true;
        this.nonEmpty = false;
    }
    get() {
        throw new TypeError('None can not #get');
    }
    toString() {
        return 'None';
    }
}
/**
 * This object represents non-existent values.
 */
exports.None = new NoneImpl();
// Builders
class OptionalBuilder1 {
    constructor(oa, ob) {
        this.oa = oa;
        this.ob = ob;
    }
    run(f) {
        return this.oa.apply1(this.ob, f);
    }
    chain(oc) {
        return new OptionalBuilder2(this.oa, this.ob, oc);
    }
}
exports.OptionalBuilder1 = OptionalBuilder1;
class OptionalBuilder2 {
    constructor(oa, ob, oc) {
        this.oa = oa;
        this.ob = ob;
        this.oc = oc;
    }
    run(f) {
        return this.oa.apply2(this.ob, this.oc, f);
    }
    chain(od) {
        return new OptionalBuilder3(this.oa, this.ob, this.oc, od);
    }
}
exports.OptionalBuilder2 = OptionalBuilder2;
class OptionalBuilder3 {
    constructor(oa, ob, oc, od) {
        this.oa = oa;
        this.ob = ob;
        this.oc = oc;
        this.od = od;
    }
    run(f) {
        return this.oa.apply3(this.ob, this.oc, this.od, f);
    }
    chain(oe) {
        return new OptionalBuilder4(this.oa, this.ob, this.oc, this.od, oe);
    }
}
exports.OptionalBuilder3 = OptionalBuilder3;
class OptionalBuilder4 {
    constructor(oa, ob, oc, od, oe) {
        this.oa = oa;
        this.ob = ob;
        this.oc = oc;
        this.od = od;
        this.oe = oe;
    }
    run(f) {
        return this.oa.apply4(this.ob, this.oc, this.od, this.oe, f);
    }
    chain(of) {
        return new OptionalBuilder5(this.oa, this.ob, this.oc, this.od, this.oe, of);
    }
}
exports.OptionalBuilder4 = OptionalBuilder4;
class OptionalBuilder5 {
    constructor(oa, ob, oc, od, oe, of) {
        this.oa = oa;
        this.ob = ob;
        this.oc = oc;
        this.od = od;
        this.oe = oe;
        this.of = of;
    }
    run(f) {
        return this.oa.apply5(this.ob, this.oc, this.od, this.oe, this.of, f);
    }
}
exports.OptionalBuilder5 = OptionalBuilder5;
