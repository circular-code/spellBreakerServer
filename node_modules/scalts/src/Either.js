"use strict";
/* tslint:disable:no-use-before-declare */
Object.defineProperty(exports, "__esModule", { value: true });
const Optional_1 = require("./Optional");
/**
 * The right side of the disjoint union, as opposed to the Left side.
 * @param b
 * @constructor
 */
function Right(b) {
    return new RightImpl(b);
}
exports.Right = Right;
/**
 * The left side of the disjoint union, as opposed to the Right side.
 * @param a
 * @constructor
 */
function Left(a) {
    return new LeftImpl(a);
}
exports.Left = Left;
function Either(cond, left, right) {
    return !cond ? Left(left()) : Right(right());
}
exports.Either = Either;
/**
 * Either implementation.
 */
class EitherImpl {
    toString() {
        return this.isLeft ? `Left(${this.value})` : `Right(${this.value})`;
    }
    /** @override */
    left() {
        return new LeftProjection(this);
    }
    /** @override */
    right() {
        return new RightProjection(this);
    }
    /** @override */
    fold(fa, fb) {
        return this.isLeft ? fa(this.value) : fb(this.value);
    }
    /** @override */
    swap() {
        return this.isLeft ? Right(this.value) : Left(this.value);
    }
    /** @override */
    foreach(f) {
        if (this.isRight) {
            f(this.value);
        }
    }
    /** @override */
    getOrElse(dv) {
        return this.isLeft ? dv() : this.value;
    }
    /** @override */
    contains(elem) {
        return this.isRight && this.value === elem;
    }
    /** @override */
    forall(f) {
        return this.isLeft || f(this.value);
    }
    /** @override */
    exists(f) {
        return this.isRight && f(this.value);
    }
    /** @override */
    map(f) {
        return this.isLeft ? Left(this.value) : Right(f(this.value));
    }
    /** @override */
    flatMap(f) {
        return this.isLeft ? Left(this.value) : f(this.value);
    }
    /** @override */
    toOptional() {
        return this.isLeft ? Optional_1.None : Optional_1.Some(this.value);
    }
    /** @override */
    match(pf) {
        return this.fold(pf.Left, pf.Right);
    }
    chain(ob) {
        return new EitherBuilder1(this, ob);
    }
    apply1(ob, f) {
        return this.flatMap(a => ob().map(b => f(a, b)));
    }
    apply2(ob, oc, f) {
        return this.flatMap(a => ob().flatMap(b => oc().map(c => f(a, b, c))));
    }
    apply3(ob, oc, od, f) {
        return this.flatMap(a => ob().flatMap(b => oc().flatMap(c => od().map(d => f(a, b, c, d)))));
    }
    apply4(ob, oc, od, oe, f) {
        return this.flatMap(a => ob().flatMap(b => oc().flatMap(c => od().flatMap(d => oe().map(e => f(a, b, c, d, e))))));
    }
    apply5(ob, oc, od, oe, of, f) {
        return this.flatMap(a => ob().flatMap(b => oc().flatMap(c => od().flatMap(d => oe().flatMap(e => of().map(ff => f(a, b, c, d, e, ff)))))));
    }
}
//------------------------------------
//
// Implementation section.
//
//------------------------------------
/**
 * Left implementation.
 */
class LeftImpl extends EitherImpl {
    constructor(value) {
        super();
        this.value = value;
        this.isLeft = true;
        this.isRight = false;
    }
}
/**
 * Right implementation
 */
class RightImpl extends EitherImpl {
    constructor(value) {
        super();
        this.value = value;
        this.isLeft = false;
        this.isRight = true;
    }
}
/**
 * Left project.
 */
class LeftProjection {
    constructor(self) {
        this.self = self;
    }
    toString() {
        return `LeftProjection(${this.self.toString()})`;
    }
    get() {
        if (this.self.isLeft) {
            return this.self.value;
        }
        else {
            throw new Error('cannot get Left value');
        }
    }
    foreach(f) {
        if (this.self.isLeft) {
            f(this.self.value);
        }
    }
    getOrElse(x) {
        return this.self.isLeft ? this.self.value : x();
    }
    forall(f) {
        return this.self.isLeft ? f(this.self.value) : true;
    }
    exists(f) {
        return this.self.isLeft ? f(this.self.value) : false;
    }
    filter(f) {
        if (this.self.isLeft) {
            return f(this.self.value) ? Optional_1.Optional.apply(this.self) : Optional_1.None;
        }
        else {
            return Optional_1.None;
        }
    }
    map(f) {
        return this.self.isLeft ? Left(f(this.self.value)) : this.self;
    }
    flatMap(f) {
        return this.self.isLeft ? f(this.self.value) : this.self;
    }
    toOptional() {
        return this.self.isLeft ? Optional_1.Optional.apply(this.self.value) : Optional_1.None;
    }
}
exports.LeftProjection = LeftProjection;
/**
 * Left project.
 */
class RightProjection {
    constructor(self) {
        this.self = self;
    }
    toString() {
        return `RightProjection(${this.self.toString()})`;
    }
    get() {
        if (this.self.isRight) {
            return this.self.value;
        }
        else {
            throw new Error('cannot get Right value');
        }
    }
    foreach(f) {
        if (this.self.isRight) {
            f(this.self.value);
        }
    }
    getOrElse(x) {
        return this.self.isRight ? this.self.value : x();
    }
    forall(f) {
        return this.self.isRight ? f(this.self.value) : true;
    }
    exists(f) {
        return this.self.isRight ? f(this.self.value) : false;
    }
    filter(f) {
        if (this.self.isRight) {
            return f(this.self.value) ? Optional_1.Optional.apply(this.self) : Optional_1.None;
        }
        else {
            return Optional_1.None;
        }
    }
    map(f) {
        return this.self.isLeft ? this.self : Right(f(this.self.value));
    }
    flatMap(f) {
        return this.self.isLeft ? this.self : f(this.self.value);
    }
    toOptional() {
        return this.self.isRight ? Optional_1.Optional.apply(this.self.value) : Optional_1.None;
    }
}
exports.RightProjection = RightProjection;
class EitherBuilder1 {
    constructor(oa, ob) {
        this.oa = oa;
        this.ob = ob;
    }
    run(f) {
        return this.oa.apply1(this.ob, f);
    }
    chain(oc) {
        return new EitherBuilder2(this.oa, this.ob, oc);
    }
}
exports.EitherBuilder1 = EitherBuilder1;
class EitherBuilder2 {
    constructor(oa, ob, oc) {
        this.oa = oa;
        this.ob = ob;
        this.oc = oc;
    }
    run(f) {
        return this.oa.apply2(this.ob, this.oc, f);
    }
    chain(od) {
        return new EitherBuilder3(this.oa, this.ob, this.oc, od);
    }
}
exports.EitherBuilder2 = EitherBuilder2;
class EitherBuilder3 {
    constructor(oa, ob, oc, od) {
        this.oa = oa;
        this.ob = ob;
        this.oc = oc;
        this.od = od;
    }
    run(f) {
        return this.oa.apply3(this.ob, this.oc, this.od, f);
    }
    chain(oe) {
        return new EitherBuilder4(this.oa, this.ob, this.oc, this.od, oe);
    }
}
exports.EitherBuilder3 = EitherBuilder3;
class EitherBuilder4 {
    constructor(oa, ob, oc, od, oe) {
        this.oa = oa;
        this.ob = ob;
        this.oc = oc;
        this.od = od;
        this.oe = oe;
    }
    run(f) {
        return this.oa.apply4(this.ob, this.oc, this.od, this.oe, f);
    }
    chain(of) {
        return new EitherBuilder5(this.oa, this.ob, this.oc, this.od, this.oe, of);
    }
}
exports.EitherBuilder4 = EitherBuilder4;
class EitherBuilder5 {
    constructor(oa, ob, oc, od, oe, of) {
        this.oa = oa;
        this.ob = ob;
        this.oc = oc;
        this.od = od;
        this.oe = oe;
        this.of = of;
    }
    run(f) {
        return this.oa.apply5(this.ob, this.oc, this.od, this.oe, this.of, f);
    }
}
exports.EitherBuilder5 = EitherBuilder5;
